## 托管和非托管
1. 托管代码CLR由运行环境执行的代码（非操作系统）可以自动获得语言运行库服务，自动垃圾回收，类型检查，安全等。
2. 不能直接访问内存，所以不使用指针（没有直接操作底层API，而是通过环境），需要创建类库即dll。
非托管代码与公共语言运行库无关，生成机器可以直接执行的二进制代码。

## 内存分区
- 栈区：由编译器自动分配释放，存放值类型的对象本身，引用类型的引用地址，静态区对象的引用地址（指针），常量区对象的引用地址（指针）。栈是由多个线程栈组成
    - 线程栈：在运行时都会维护一个自己的专属线程堆栈
- 堆区：存放引用类型的对象本身。在C#中由.net平台的垃圾回收机制管理。栈、堆都属于动态存储区，可以实现动态分配。  
    >对象的浅表大小指的是对象里面包含的字段数量，或者说是数组本身等。浅表大小就是对象本身的实际占用内存的大小，而不加上对象包含的引用的其他对象的大小，例如一个定义了 100 个字段的对象，这个对象定义的这 100 个字段都是指向其他的引用对象，此时这个对象的浅表大小仅仅是 100 个指针长度的大小加上一个空对象占用的大小。因此基本上能作为大对象的都是数组。在dotnet中，根据对象的浅表大小使用85kb作为界限

    - 小对象堆：由于移动对象的成本很低，小对象堆更多采用压缩回收法
    - 大对象堆：对象的浅表大小大于85kb时为大对象，放入大对象堆。优先执行标记清除内存法，一段时间后再执行压缩内存法
    - GC堆：用于分配小对象堆实例
- 静态区和常量区：存放静态类，静态成员，常量的对象本身。存在栈内的引用地址在程序运行时最先进栈。因此静态区和常量区的对象生命周期会持续到程序运行结束时，静态区和常量区对象才会被释放和回收（编译器自动释放）。
- 代码区：存放函数体的二进制代码。

## 内存分配
1. 值类型在栈上分配空间。
2. 引用类型（对象本身）在堆区分配空间，但是引用地址还是在栈区，通过引用地址去堆区内寻找对象本身。只有引用类型会涉及到深拷贝的问题。


## 参考链接
1. https://blog.csdn.net/qq_27825451/article/details/102581255